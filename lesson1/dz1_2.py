'''
2. Выполнить логические побитовые операции «И», «ИЛИ» и др. над числами 5 и 6. Выполнить над числом 5 побитовый сдвиг вправо и влево на два знака. Объяснить полученный результат.
'''
a = bin(5)[2:] # присваиваем в переменные побитовое предстваление числа 5
b = bin(6)[2:] # отсекаем первые символы - обозначающие разрядность "0b" 
print(f'предстваление числа "5" : {a}, в двоичной системе счисления')
print(f'предстваление числа "6" : {b}, в двоичной системе счисления')
# для требуемых чисел достаточно 3х разрядов, поэтому не буду усложнять код незначащими нулями до 8-ми рязрядов байта
a1, a2, a3 = int(a[0]), int(a[1]), int(a[2]) # разбиваем представление в двоичной системе на символы
b1, b2, b3 = int(b[0]), int(b[1]), int(b[2]) # и преобразуем каждый символ к числу 
# эмуляция побитовых операций - так же как в первой задаче, примем допущение что требуется только вывод, поэтому сократим код за счет отказа от промежуточных присвоений
# побитовое И - выполним оперции над каждой парой чисел, для контроля добавил результат встроеной функции python
print(f'побитовое И : {(a1 & b1)}{(a2 & b2)}{(a3 & b3)} (контрольный результат - {bin(5 & 6)})')
##побитовое ИЛИ
print(f'побитовое ИЛИ : {(a1 | b1)}{(a2 | b2)}{(a3 | b3)} (контрольный результат - {bin(5 | 6)})')
##побитовое XOR
print(f'побитовое XOR : {(a1 ^ b1)}{(a2 ^ b2)}{(a3 ^ b3)} (контрольный результат - {bin(5 ^ 6)})')
##сдвиг влево - равнозначен тому что справа будут добавлены как бы два символа a4 и a5 равные 0 и первая цифра "1" переместится из 3го разряда в 5
print(f'сдвиг влево на два знача числа "5" : {a1}{a2}{a3}00 (контрольный результат - {bin(5 << 2)})')
##сдвиг вправо - равнозначно присвоению первых двух символов a1 и a2 в ноль 0
print(f'сдвиг вправо на два знача числа "5" : 00{a3} (контрольный результат - {bin(5 >> 2)})')
