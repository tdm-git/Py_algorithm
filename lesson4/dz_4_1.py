""" Проанализировать скорость и сложность одного любого алгоритма, разработанных в рамках практического задания первых
трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их. """
# возьму за основу задачу - Сформировать из введенного числа обратное по порядку входящих в него цифр и вывести на экран
import timeit
import cProfile


#  1. вариант через рекурсию
def new_num(num):
    if num < 10:
        return num
    return new_num(num // 10) + ((num % 10) * 10 ** (len(str(num)) - 1))


def new_num2(num, rank):
    if num < 10:
        return num
    return new_num2(num // 10, rank - 1) + ((num % 10) * 10 ** rank)


#  2. вариант напрямую - через "пересборку" строки
def list_num(num):
    result = ''
    for i in num:
        result = i + result
    return result


# соберём в одну функцию все варианты
def main_loop(n, var):
    if var == 1:
        return new_num(n)
    elif var == 2:
        return new_num2(n, len(str(n)) - 1)
    else:
        return list_num(str(n))


# user_input = input("введите целое натуральное число - ")
user_input = 2374867362352653752364872368723687424736762567253653276252367522745236725476235523357625273457654
print('первый вариант рекурсия -', timeit.timeit(f'main_loop({user_input}, 1)', globals=globals(), number=10000))
print('второй вариант рекурсии -', timeit.timeit(f'main_loop({user_input}, 2)', globals=globals(), number=10000))
print('третий вариант, через цикл и строку - ',
      timeit.timeit(f'main_loop({user_input}, 3)', globals=globals(), number=10000))
'''
1-й вариант решения через рекурсию, сложность алгоритма O(2*n) 
2-й вариант тоже через рекурсию, но отказался от функции len() в пользу параметра, сложность алгоритма O(n)
3-й вариант, использует возможность цикла for итерировать строку, без промежуточных расчетов - показало самое 
минимальное время, сложность алгоритма O(n)
проводил эксперементы с длиной вводимого числа - рост длительность выполнения линейный
'''
print('анализ через профайлер: ')
cProfile.run(f'main_loop({user_input}, 1)')
cProfile.run(f'main_loop({user_input}, 2)')
cProfile.run(f'main_loop({user_input}, 3)')
'''
разбор решения в профайлере первого решения сразу показал неоптимальность (многократный вызов функции len()) 
и привёл ко второму варианту решения, с использованием второго уменьшающегося параметра
'''
