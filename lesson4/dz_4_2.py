""" Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования Решета Эратосфена;
Использовать алгоритм решето Эратосфена """
import timeit
from math import sqrt


#  1. вариант из методички 2-го урока
# n = int(input("вывод простых чисел до числа ... "))
def num_list1(n):
    a = [0] * n  # создание массива с n количеством элементов
    for i in range(n):  # заполнение массива ...
        a[i] = i  # значениями от 0 до n-1
    # вторым элементом является единица, которую не считают простым числом
    # забиваем ее нулем.
    a[1] = 0
    m = 2  # замена на 0 начинается с 3-го элемента (первые два уже нули)
    while m < n:  # перебор всех элементов до заданного числа
        if a[m] != 0:  # если он не равен нулю, то
            j = m * 2  # увеличить в два раза (текущий элемент - простое число)
            while j < n:
                a[j] = 0  # заменить на 0
                j = j + m  # перейти в позицию на m больше
        m += 1
    # вывод простых чисел на экран (может быть реализован как угодно)
    b = []
    for i in a:
        if a[i] != 0:
            b.append(a[i])
    del a
    return b


# 2. вариант - в лоб, перебираем и проверяем на кратность
# n = int(input("вывод простых чисел до числа ... "))
def num_list2(n):
    a = []
    for i in range(2, n + 1):
        for j in a:  # пробегаем по списку простых чисел
            if i % j == 0:
                break
        else:
            a.append(i)
    return a


# 3.Вариант - поиск в интернете показал что есть вариант с использованием кв.корня
def num_list3(n):
    a = []
    for i in range(2, n + 1):
        for j in a:
            if j > int((sqrt(i)) + 1):
                a.append(i)
                break
            if i % j == 0:
                break
        else:
            a.append(i)
    return a


num_list = (100, 1000, 10000)
for n in num_list:
    print(f'тестирование получения списка до числа - {n}')
    print(f'1.решето Эратосфена -', timeit.timeit(f'num_list1({n})', globals=globals(), number=1000))
    print(f'2.цикл в цикле -', timeit.timeit(f'num_list2({n})', globals=globals(), number=1000))
    print(f'3.через корень числа -', timeit.timeit(f'num_list3({n})', globals=globals(), number=1000))


''' 1-й вариант с решетом Эратосфена показал стабильно хороший результат, тогда как на небольших выборках простой 
перебор 2-й вариант был быстрее математического варианта 3, через поиск корня. Но на построение списка 10к элементов,
такой алгоритм уже показал превосходство над простым перебором...

1-й - сложность O(С*n), т.е. несколько раз пробегаемся по длине n
2-й - как понимаю "классический вариант" квадратичного неоптимального цикла O(n**2)
3-й - мне сложно оценить, с одной стороны тоже вложенный цикл, но break сокращает вложенную выборку, поэтому предположу
      что тут представлена сложность O(n*log n)  
'''